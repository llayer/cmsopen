
1	
2	 /***************************************************************************** 
3	  * Project: RooFit                                                           * 
4	  *                                                                           * 
5	  * This code was autogenerated by RooClassFactory                            * 
6	  *****************************************************************************/ 
7	
8	 // Your description goes here... 
9	
10	// #include "Riostream.h" 
11	
12	#include "FuncCB.h" 
13	#include "RooAbsReal.h" 
14	#include "RooAbsCategory.h" 
15	#include "RooMath.h"
16	
17	#include <math.h> 
18	#include "TMath.h" 
19	#include <limits>
20	
21	
22	 ClassImp(FuncCB) 
23	
24	 FuncCB::FuncCB(const char *name, const char *title, 
25	                        RooAbsReal& _m,
26	                        RooAbsReal& _m0,
27	                        RooAbsReal& _sigma,
28	                        RooAbsReal& _alpha,
29	                        RooAbsReal& _n,
30	                        RooAbsReal& _norm) :
31	   RooAbsReal(name,title), 
32	   m("m","m",this,_m),
33	   m0("m0","m0",this,_m0),
34	   sigma("sigma","sigma",this,_sigma),
35	   alpha("alpha","alpha",this,_alpha),
36	   n("n","n",this,_n),
37	   norm("norm","norm",this,_norm)
38	 { 
39	 } 
40	
41	
42	 FuncCB::FuncCB(const FuncCB& other, const char* name) :  
43	   RooAbsReal(other,name), 
44	   m("m",this,other.m),
45	   m0("m0",this,other.m0),
46	   sigma("sigma",this,other.sigma),
47	   alpha("alpha",this,other.alpha),
48	   n("n",this,other.n),
49	   norm("norm",this,other.norm)
50	 { 
51	 } 
52	
53	
54	
55	 Double_t FuncCB::evaluate() const 
56	 { 
57	   const double sqrtPiOver2 = 1.2533141373;
58	   const double sqrt2 = 1.4142135624;
59	
60	   Double_t sig = fabs((Double_t) sigma);
61	   
62	   Double_t t = (m - m0)/sig ;
63	   
64	   if (alpha < 0)
65	     t = -t;
66	
67	   Double_t absAlpha = fabs(alpha / sig);
68	   Double_t a = TMath::Power(n/absAlpha,n)*exp(-0.5*absAlpha*absAlpha);
69	   Double_t b = absAlpha - n/absAlpha;
70	
71	   if (a>=std::numeric_limits<double>::max()) return -1. ;
72	   //cout<<"P1 "<<absAlpha<<" "<<a<<" "<<b<<endl ;
73	
74	   Double_t aireGauche = (1 + ApproxErf( absAlpha / sqrt2 )) * sqrtPiOver2 ;
75	   Double_t aireDroite = ( a * 1/TMath::Power(absAlpha - b,n-1)) / (n - 1);
76	   Double_t aire = aireGauche + aireDroite;
77	
78	   //cout<<"P2 "<<aireGauche<<" "<<aireDroite<<" "<<aire<<endl ;
79	
80	   if ( t <= absAlpha ){
81	     return norm * (1 + ApproxErf( t / sqrt2 )) * sqrtPiOver2 / aire ;
82	   }
83	   else{
84	     return norm * (aireGauche +  a * (1/TMath::Power(t-b,n-1) - 1/TMath::Power(absAlpha - b,n-1)) / (1 - n)) / aire ;
85	   }
86	  
87	 } 
88	
89	
90	//_____________________________________________________________________________
91	Double_t FuncCB::ApproxErf(Double_t arg) const 
92	{
93	  static const double erflim = 5.0;
94	  if( arg > erflim )
95	    return 1.0;
96	  if( arg < -erflim )
97	    return -1.0;
98	  
99	  return RooMath::erf(arg);
100	}
101	
102	
